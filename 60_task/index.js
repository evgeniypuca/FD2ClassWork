// #1 Решена
// Напишите функцию, которая принимает массив и переносит все 0 в конец,
// не изменяя порядок остальных элементов массива.

// Например:
// moveZeros([false,1,0,1,2,0,1,3,"a"]) --> [false,1,1,2,1,3,"a",0,0]

function moveZeros(arr) {
    return arr.sort((a, b) => {
        if (a === 0 && b !== 0) {
            return 1;
        } else if (a !== 0 && b === 0) {
            return -1;
        } else {
            return 0;
        }
    });
}
console.log(moveZeros([false, 1, 0, 1, 2, 0, 1, 3, "a"]));

// #2
// Найдите недостающую букву.
// Напишите функцию,  которая принимает в качестве параметра массив букв, 
// расположенных по алфавиту и возвращает массив с недостающей буквой. 
// Длина входного массива не меньше 2 и он содержит буквы только одного регистра.

// Например:
// findMissingLetter(['a','b','c','d','f']) --> 'e'


function findMissingLetter(arr) {
    let str = arr.join('');
    console.log(str);
    for (let i = 0; i < str.length; i++) {
        if (!str.includes(String.fromCharCode(str.charCodeAt(i + 1)))) {
            console.log(String.fromCharCode(str.charCodeAt(i)));
        }
        // if ((arr[i + 1].charCodeAt(0)) - arr[i].charCodeAt(0) > 1) {
        //     secondaryArr.push(String.fromCharCode(arr[i].charCodeAt(+1)));
        // }
    }

}


console.log(findMissingLetter(['a', 'b', 'c', 'd', 'f']));


// #3 решена
// Вы, наверное, знаете систему «лайков» по Facebook и другим страницам. 
// Люди могут "лайкать" сообщения в блогах,изображения или другие предметы. 
// Мы хотим создать текст, который должен отображаться рядом с таким элементом.
// Реализуйте функцию likes :: [String] -> String, которая 
// должна принимать входной массив, содержащий имена людей,которым нравится элемент. 
// Он должен возвращать отображаемый текст, как показано в примерах:

// Например:
// likes([]) --> 'no one likes this'
// likes(['Peter']) --> 'Peter likes this'
// likes(['Jacob', 'Alex']) --> 'Jacob and Alex like this'
// likes(['Max', 'John', 'Mark']) --> 'Max, John and Mark like this')
// likes(['Alex', 'Jacob', 'Mark', 'Max']) --> 'Alex, Jacob and 2 others like this'

function likes(arr) {
    switch (arr.length) {
        case 0:
            return 'no one likes this';
        case 1:
            return `${arr[0]} likes this`;
        case 2:
            return `${arr[0]} and ${arr[1]} like this`;
        case 3:
            return `${arr[0]}, ${arr[1]} and ${arr[2]} like this`;
        default:
            return `${arr[0]}, ${arr[1]} and 2 others like this`;
    }
}

console.log(likes(['Alex', 'Jacob', 'Mark', 'Max']));

// #4 Решена
// Что такое анаграмма?
// Два слова являются анаграммами между собой,если
// они оба содержат одинаковые буквы. 
// Например: 'abba' & 'baab' == true
// Напишите функцию, которая находит все анаграммы слова из списка. 
// В качестве параметра даны слово и массив слов. 
// Функция должна возвращать массив всех анаграмм или пустой массив,
// если анаграмм не обнаружено.
// Например:
// anagrams('abba', ['aabb', 'abcd', 'bbaa', 'dada']) --> ['aabb', 'bbaa']

function anagrams(word, arr) {
    const sortsWord = word.split('').sort().join('');
    let finalArr = [];

    for (const elem of arr) {
        if (sortsWord === elem.split('').sort().join('')) {
            finalArr.push(elem);
        }
    }
    return finalArr;
}

console.log(anagrams('abba', ['aabb', 'abcd', 'bbaa', 'dada']));

// #5 решена
// Представим автобус, забирающий и высаживающий людей на каждой остановке. 
// Дан массив массивов, первый элемент которых равен числу пассажиров,
// вошедших в автобус на остановке, а второй - числу пассажиров,
// вышедших на остановке.

// Ваша Задача написать функцию, которая возвращает число людей,
// оставшихся в автобусе после последней остановки (массива).
// Хоть это и последняя остановка,
// в автобусе все еще находятся люди (они, наверное, уснули :D ).

// Помните, что число оставшихся людей в автобусе всегда >= 0
// Значение второго числа первого элемента массива = 0, 
// потому что автобус пустой на первой остановке.

// Например:
// busStops([[3, 0], [9, 1], [4, 10], [12, 2], [6, 1], [7, 10]]) --> 17

function busStops(arr) {
    let count = 0;
    for (const elem of arr) {
        count += elem[0];
        count -= elem[1];
    }
    return count;
}

console.log(busStops([[3, 0], [9, 1], [4, 10], [12, 2], [6, 1], [7, 10]]));

// #6 решена
// Даны две строки, которые содержат только буквы от a - z.
// Ваша задача написать функцию, которая возвращает
// новую отсортированную (по порядку) строку,
// которая содержит буквы двух строк, повторяющихся только один раз.

// Например:
// longest("xyaabbbccccdefww", "xxxxyyyyabklmopq") --> "abcdefklmopqxy"

function longest(str1, str2) {
    let secondaryStr = (str1 + str2).split('').sort();
    let finalStr = '';
    for (const elem of secondaryStr) {
        if (!finalStr.includes(elem)) {
            finalStr += elem;
        }
    }
    return finalStr;
}
console.log(longest("xyaabbfdvdfvdfvdfvdfvbccccdefww", "xxxxyyyyabklmopq"));

// #7 решена
// Ваша задача написать функцию, которая принимает 
// в качестве параметра целое число и возводит в квадрат каждую цифру числа. 
// Результат также необходимо вернуть в виде целого числа.

// Например:
// squareDigits(9119) --> 811181

function squareDigits(num) {
    const strNum = num.toString();
    let resultNum = '';
    for (const elem of strNum) {
        resultNum += elem * elem;
    }
    return +resultNum;
}
console.log(squareDigits(9119));

// #8 решена
// Для того, чтобы обеспечить безопасность данных при оплате онлайн,
// нам необходимо замаскировать все цифры банковского счета, кроме последних четырех. 

// Ваша задача написать функцию, которая принимает в качестве 
// параметра строку, состоящую из цифр, заменяет все элементы на  '#', 
// кроме последних четырех и возвращает ее.

// Например:
// maskify("4556364607935616") --> "############5616"

function maskify(str) {
    let finalStr = '';
    for (let i = 0; i < str.length; i++) {
        if (i < str.length - 4) {
            finalStr += '#';
        } else {
            finalStr += str[i];
        }

    }
    return finalStr;
}

console.log(maskify("4556364607935616"));

// #9 решена
// Дан массив слов, необходимо определить, 
// составлены ли все слова из одних и тех же символов.
// Например:
// ["ток", "ток", "кто"] --> true
// ["кот", "тк", "кТо"] --> false


function isTrueArr(arr) {
    const firstElem = arr[0].split('').sort().join('');
    for (let elem of arr) {
        if (firstElem !== elem.split('').sort().join('')) {
            return false;
        }
    }
    return true;
}
console.log(isTrueArr(["кто", "ток", "ктво"]));

// #10 решена
// Напишите функцию, которая возвращает сумму таким образом:

// Например:
// f(1)(2)(3) --> 6

function sum(a) {
    return function (b) {
        return function (c) {
            return a + b + c;
        }
    }
}

console.log(sum(1)(2)(10));

//#11 решена
// Напишите функцию, которая находит наиболее часто используемый элемент массива.

// Например:
// const array=[7, 'z', 'z', 'z', 3, 7, 'z', 7, 'z', 3, 5, 7]; --> "z"

const array = [1, 'z', 'z', 'z', 3, 1, 'z', 1, 'z', 3, 5, 'z', 'z', 'z', 'z', 'z', 1, 1, 1,];

function getOftenElement(arr) {
    const countObj = arr.reduce((acc, e) => {
        acc[e] = (acc[e] ?? 0) + 1;
        return acc;
    }, {});

    let oftenElement = null;
    let count = 0;
    const key = Object.keys(countObj);

    for (let elem of key) {
        if (countObj[elem] > count) {
            count = countObj[elem];
            oftenElement = elem;
        }
    }
    return oftenElement;
}

console.log(getOftenElement(array));

// 12 решена
// Напишите функцию `expand(arr)`, которая разворачивает 
// вложенный массив любой глубины.

// Например:
// const arr1 = [1, [2,[3,[4]]]]; --> [1,2,3,4]; 
// const arr2 = [1, [2], [3, [[4]]],[5,6]]; --> [1,2,3,4,5,6];
const arr1 = [1];
const arr2 = [1, [2], [3, [[4]]], [5, 6]];

function expand(arr) {
    return arr.reduce((acc, elem) => {
        let result = elem instanceof Array ? expand(elem) : elem;
        return acc.concat(result);
    }, []);
}
console.log(expand(arr1));
console.log(expand(arr2));
console.log(arr2.flat());


//#13 решена
// Напишите функцию с двумя параметрами, которая создаёт массив элементов, 
// представляющих собой сумму соответствующих элементов заданных массивов.

// Например:
const array1 = [1, 2, 3, 4, 5];
const array2 = [4, 5, 6];


function getSummArrays (array1, array2) {
    let obj = {};
    array1.forEach((element, index) => {
        obj[index] = element;
    });
    array2.forEach((element, index) => {
        obj[index] += element;
    });
    return Object.values(obj);
}

console.log(getSummArrays(array1,array2));
 // [5,7,9,4,5]


 // 14 решена
//  Напишите функцию `removeDuplicates(arr)`, которая возвращает массив,
//  в котором удалены повторяющиеся элементы из массива arr.
 
//  Например:
//  let arr = ["php", "php", "css", "css",
//    "script", "script", "html", "html", "java"
//  ];
 
//  removeDuplicates(arr); --> ["php","css","script","html","java"]

 let arr = ["php", "php", "css", "css",
   "script", "script", "html", "html", "java"
 ];

function removeDuplicates(arr) {
    const obj = arr.reduce((acc, elem) => {
        acc[elem] = elem;
        return acc;
    },{});
    return Object.keys(obj);
    
};

console.log( removeDuplicates(arr));


// 15 решена
// Напишите функцию colonOdd(num), которая принимает число num в 
// качестве аргумента и вставляет двоеточие (:) между двумя нечетными числами. 
// Например, если вводится число 55639217, то на выходе должно быть 5:563:921:7

function colonOdd(num) {
    let arr = num.toString().split('');
    let resultArr = [];
    for (let i = 0; i < arr.length; i++){
        if (arr[i] % 2 !== 0 && arr[i + 1] % 2 !== 0 && i !== arr.length - 1){
            resultArr.push(`${arr[i]}:`);
        } else {
            resultArr.push(arr[i]);
        }
    }
    return resultArr.join('');
}   

console.log(colonOdd(5563921777));

// 16 решена но не понял точком условия
// Напишите функцию `copyArr(arr)`, которая копирует массив, не изменяя оригинал.

// Например:
// const vegetables = ['Капуста', 'Репа', 'Редиска'];

const vegetables = ['Капуста', 'Репа', 'Редиска']

function copyArr(arr){
    return [...arr]
}

console.log(copyArr(vegetables));

// 17 решена
// Создайте метод объекта `String endsWith()`, который сравнивает 
// подстроку str1 с окончанием исходной строки str и определяет, 
// заканчивается ли строка символами подстроки.

// Например:
const str = "Каждый охотник желает знать"; 
const str1 = "скрипт";
const str2 = "знать";

// String.prototype.endsWith = function(substring) {};

// str.endsWith(str1)) -->  false
// str.endsWith(str2)) -->  true

String.prototype.endsWith = function(substring) {
    if (this.split('').reverse().slice(0, substring.length).join('') === substring.split('').reverse().join('')) {
        return true;
    } else {
        return false;
    }
};

console.log(str.endsWith(str2))

//18 решена
// Напишите функцию `comparison(str1, str2)`, которая сравнивает
// строки без учёта регистра символов.

// Например:
// comparison('string', 'StRiNg') -->  true
// comparison('string', 'Redev') -->  false


function comparison(str1, str2) {
    return str1.toLowerCase() === str2.toLowerCase() ? true : false;
}
console.log(comparison('string', 'StRiNg'));


//19
// Напишите функцию `strip(str)`, которая удаляет все лишние пробелы из строки str.

// Например:
// const str = "    Pasha is a good      boy     ";
// strip(str) --> "Pasha is a good boy"

const strin = "    Pasha is a good      boy     ";

function strip(str) {
   let result = str.split('').reduce((acc, elem, index, arr) => {
        if (!(elem == ' ' && arr[index - 1] == ' ') ) {
            acc.push(elem);
        }
        return acc;
   },[]);

   return result.join('').trim();

}
console.log(strip(strin));


//20 решена
// Напишите функцию `cutString(str, n)`, которая удаляет лишние 
// слова из строки str, оставив в ней n слов.

// Например:
// const str = "Сила тяжести приложена к центру масс тела";`
// cutString(str, 5) --> "Сила тяжести приложена к центру"



const str = "Сила тяжести приложена к центру масс тела";
// cutString(str, 5) --> "Сила тяжести приложена к центру"


function cutString(str, n) {
    return  str.split(' ').filter((elem, index, arr) => {
      return  index < n; 
     }).join(' ');
}

console.log(cutString(str, 5));



// 21 solve
// Напишите функцию `alphabetize(str)`, которая возвращает строку,
// отсортировав её символы в алфавитном порядке.

// Например:
// alphabetize("redev") --> "deerv"
// ```

function alphabetize(str) {
    return str.split('').sort((a, b) =>{
        return a.charCodeAt() - b.charCodeAt();
    }).join('');
}

console.log(alphabetize('redev'));


// 22 solve
// Напишите функцию `uniqueLetters(str)`, которая возвращает строку,
// оставив в ней только уникальные символы, т.е. встречающиеся в строке один раз.

// Например:
// uniqueLetters('anaconda'); --> 'ancod'
// uniqueLetters('redev'); --> 'redv'
// ```

function uniqueLetters(str){
    return Array.from(new Set(str.split(''))).join('');
}

console.log(uniqueLetters('anaconda'));

// 23 solve
// Напишите функцию `removeDuplicate(str)`, которая возвращает строку,
// очищенную от слов-дупликатов, т.е. 
// каждое слово должно повторяться не более одного раза.

// const str = "вишня, груша, слива, груша";

// Например:
// removeDuplicate(str) --> "вишня, груша, слива"
// ```

function removeDuplicate(str) {
    return Array.from(new Set(str.split(', '))).join(', ');

}
console.log(removeDuplicate("вишня, груша, слива, груша"));

// 24 solve
// Напишите функцию `replaceAll(find, replace, str)`, 
// которая заменяет в строке str все вхождение подстроки find на подстроку replace.

// let str = 'abc def def lom abc abc def';

// Например:
// replaceAll('abc', 'x', str) --> 'x def def lom x x def'
// ```
let str = 'abc def def lom abc abc def';
function replaceAll(find, replace, str){
    return str.split(' ').map((elem) => {
        return elem === find ? replace : elem;
    }).join(' ');
}

console.log(replaceAll('def', 'x', str));

// 25 solve
// Напишите функцию `startsWith()`, которая определяет, начинается ли строка символами другой строки, возвращая, соотвественно, true или false.

// let str = 'abc def ghi jkl mno pqr stu';

// Например:
// str.startsWith('abc') --> 
// ```
let str = 'abc def ghi jkl mno pqr stu';
function startsWith(symb,str){
    let result;
    for (let i = 0; i < symb.length; i++) {
        str[i] === symb[i] ? result = true : result = false;
    }
    return result;
}
console.log(startsWith('abcd', str));

// 26 
// Напишите функцию capitalizeFirstLetter(str), 
// которая преобразовывает первый символ строки в верхний регистр.
// ```

function capitalizeFirstLetter(str){

    return str.charAt(0).toUpperCase() + str.slice(1) ;
}
console.log(capitalizeFirstLetter('abc def'));

// ```jsx
// Напишите функцию `isUpperCase(str, character)`, которая определяет,
// в каком регистре написан символ строки в указанной позиции.
// Если он написан в верхнем регистре - возвращать true, если в нижнем – false.

// Например:
// isUpperCase('tasks JavaScript', 6); --> true
// ```

// ```jsx

// Ваша задача - создать объект chainMaker, который создает цепочки.
// Готовая цепочка представляет собой строку
// и выглядит так: '(значение1) ~~ (значение2) ~~ (значение3)'.
// В ChainMaker есть несколько методов для создания цепочек и их изменения:

// getLength: возвращает текущую длину цепочки в виде числа;
// addLink (value) добавляет в цепочку ссылку, содержащую строковое представление значения;
// removeLink (position) удаляет звено цепи в указанной позиции;
// reverseChain: переворачивает цепочку;
// finishChain: завершает цепочку и возвращает ее.

// Методы addLink, reverseChain и removeLink объединяются в цепочку, а другие - нет.
// Если addLink вызывается без аргументов,
// он добавляет в цепочку пустую ссылку ('()').
// Если removeLink принимает недопустимую позицию
// (например, не число или дробное число, или соответствует несуществующей ссылке),
// он должен выдать ошибку.
// После вызова метода finishChain существующую цепочку необходимо удалить,
// как если бы возникла ошибка.

// Например:
// chainMaker.addLink(1).addLink(2).addLink(3).finishChain() 
// --> '(1) ~~ (2) ~~ (3)'
// chainMaker.addLink(1).addLink(2).removeLink(1).addLink(3).finishChain() 
// --> '(2) ~~ (3)'
// chainMaker.addLink(1).addLink(2).reverseChain().addLink(3).finishChain()
// --> '(2) ~~ (1) ~~ (3)'**Преобразовать массив**
// Ваша задача - реализовать функцию transform(arr), 
// которая принимает массив и возвращает преобразованный массив 
// на основе управляющих последовательностей, содержащихся в arr. 
// Управляющие последовательности - это определенные строковые элементы 
// указанного массива:

// **--discard-next** исключает следующий элемент массива из преобразованного массива.
// **--discard-prev** исключает предыдущий элемент массива из преобразованного массива.
// **--double-next** удваивает следующий элемент массива в преобразованном массиве.
// **--double-prev** удваивает предыдущий элемент массива в преобразованном массиве.

// Например:

// transform ([1, 3, '--double-next', 4]) --> [1, 3, 4, 4]
// transform ([1, 3, '--discard-prev', 4]) --> [1, 4]
// ```

// ```jsx
// Представьте, что Вы и Ваши друзья решили создать команду мечты.
// У этой команды должно быть крутое секретное имя,
// которое содержит зашифрованную информацию о ней.
// Например, это могут быть первые буквы имен его членов в верхнем регистре,
// отсортированные по алфавиту. 
// Ваша задача - написать функцию createDreamTeam (members), 
// которая возвращает имя созданной команды (строку) 
// на основе имен ее участников (Array). 
// Удачи!

// Имена участников должны быть строками. 
// Значения другого типа следует игнорировать. 
// В случае неправильного типа членов функция должна возвращать false.

// Например:
// createDreamTeam(['Matt', 'Ann', 'Dmitry', 'Max']) --> 'ADMM'
// createDreamTeam(['Olivia', 1111, 'Lily', 'Oscar', true, null]) --> 'LOO'
// ```

// ```jsx
// Напишите функцию, которая находит факториал 5.
// ```

// ```jsx
// Ваша задача  - посчитать спрятанных на заднем дворе кошек (представленных в двухмерном формате Array)
// Кошки хорошо прячутся, но их уши (''^^") видны. 
// Ваша задача написать функцию (countCats), которая будет считать кошек. Удачи!

// Количество найденых кошек должны быть `number`. 
// Если кошек не найдено, функция должна вернуть `0`

// Например:
// countCats([[0,1,"^^"],[9,"^^",2],["^^",8,7]]) --> 3
// ```

// ```jsx
// Напишите функцию, которая проверит, является ли строка палиндромом. 
// (Для того, чтобы решить эту задачу, надо загуглить)
// ```

// ```jsx
// Напишите функцию, которая переделывает строку из camelCase в snake_case.

// Например:
// solution("redevCourses") -> "redev_courses"
// ```

// ```jsx
// Напишите функцию, которая принимает строковый параметр и 
// меняет буквы в словах в обратном порядке. 
// Все пробелы в строке должны быть сохранены.

// Например:
// "This is an example!" -> "sihT si na !elpmaxe"
// ```

// ```jsx
// Ваша задача - отсортировать заданную строку. 
// Каждое слово в строке будет содержать одно число. 
// Это число - позиция, которую слово должно занимать в результате.

// Примечание: числа могут быть от 1 до 9. 
// Таким образом, 1 будет первым словом (не 0).

// Если входная строка пуста, вернуть пустую строку. 
// Слова во входной строке будут содержать только последовательные числа.

// Например:
// "is2 Thi1s T4est 3a" -> "Thi1s is2 3a T4est"
// ```

// ```jsx
// Напишите функцию, которая возвращает сумму двух наименьших положительных чисел,
// учитывая массив из минимум 4 положительных чисел.

// Например:
// [12,423,54,1235,3,15,2,52] --> 5
// ```

// ```jsx
// Напишите функцию, которая принимает число n (n> 0) и 
// возвращает строку с обратной последовательностью от n до 1.

// Например: если n = 5 на выходе у Вас должно быть "5 4 3 2 1"
// ```

// ```jsx
// В данной задаче Вам нужно удалить из одного массива все элементы второго массива.

// Например:
// arrayDiff([1,2],[1]) --> [2]
// arrayDiff([1,2,2,2,3,4],[2,3]) --> [1,4]
// ```

// ```jsx
// По заданному набору массива чисел вернуть аддитивную инверсию каждого элемента.
// Каждый позитив становится негативом, а негатив становится позитивом.

// Например:
//  invert([-1,-2,-4,-5]) --> [1,2,4,5]
//  invert([1,2,4,5]) --> [-1,-2,-4,-5]
//  invert([1,-2,4,-5]) --> [-1,2,-4,5]

// Вы можете предположить, что все значения являются целыми числами.
// Не изменяйте входной массив
// ```

// ```jsx
// Вы можете найти иголку в стоге сена?
// Напишите функцию findNeedle, которая принимает массив, полный мусора, 
// но содержащий одну иголку.

// После того, как ваша функция найдет иголку, 
// она должна вернуть сообщение (в виде строки), которое говорит:

// "Нашел иголку на позиции" плюс индекс, по которому была найдена иголку

// findNeedle(["bla","wekmvever","needle","bntyn"]) --> "Нашел иголку на позиции 2"
// ```

// ```jsx
// Функция simple, в качестве параметра принимающая строку слов,
// возвращает длину самого короткого слова

// Например:
// simple("Redev - это про дисциплину") --> 3
// ```

// ```jsx
// Напишите функцию, которая возвращает минимальное и
// максимальное значение заданного массива.

// Например:
// [1, 5, 8, 10, 35, 100] --> [1, 100]
// [-5, -7, -2, 5] --> [- 7, 5]
// ```

// ```jsx
// Джейден Смит, сын Уилла Смита, является звездой таких фильмов, 
// как «Малыш каратэ» (2010) и «После Земли» (2013). 
// Джейден также известен своей философией, которой он делится в Twitter. 
// Когда он пишет посты в Твиттере, он пишет каждое слово с заглавной буквы. 
// Посмотрите на приведенный ниже пример.

// Ваша задача - преобразовать строки в то, как они были 
// бы написаны Джейденом Смитом. 
// Строки являются реальными цитатами из Jaden Smith, 
// но они не написаны с большой буквы так, как он их первоначально напечатал.

// Например:
// toJadenCase('пишите код - это круто') --> 'Пишите Код - Это Круто'
// ```

// ```jsx
// Банкоматы допускают 4 или 6-значные ПИН-коды, 
// а ПИН-коды не могут содержать ничего, кроме 4 цифр или 6 цифр.

// Если функции передана правильная строка PIN,
// верните `true`, иначе верните `false`.

// Например:
// correctPin('5567') --> true
// correctPin('5432567') --> false
// ```

// ```jsx
// Ваша задача написать функцию, которая принимает 
// в качестве параметра строку и увеличивает каждую "букву" строки
// на число позиции, которую она занимает.

// Например:
// accum("abcd") --> "A-Bb-Ccc-Dddd"
// accum("RqaEzty") --> "R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy"
// accum("cwAt") --> "C-Ww-Aaa-Tttt"
// ```

// ```jsx
// В этом небольшом задании вам дана строка чисел, 
// разделенных пробелами, и Вы должны вернуть самое большое и самое маленькое число.

// Например:
// list("4 5 29 54 4 0 -123 666 -64 1 -3 6 -6")  --> "666 -123"
// ```

// ```jsx
// Тролли атакуют ваш раздел комментариев!

// Распространенный способ справиться с этой ситуацией - убрать 
// все гласные из комментариев троллей, нейтрализуя угрозу.
// Ваша задача - написать функцию, которая принимает строку 
// и возвращает новую строку со всеми удаленными гласными.

// Например: "Этот сайт для лузеров ЛОЛ!" --> "тт сйт дл лзрв ЛЛ!"
// ```

// ```jsx
// Допустим, Вы знакомы с понятием "идеальный квадрат". (Например: 12 * 12 = 144). 
// А как найти следующий по очереди идеальный квадрат?

// **Напишите функцию findNextSquare**, которая находит 
// следующий целочисленный идеальный квадрат после того, 
// как он передан в качестве параметра. 
// Напомним, что целочисленный идеальный квадрат - это такое 
// целое число n, sqrt (n) которого тоже является целым числом.

// Если параметр сам по себе не является идеальным квадратом, то 
// должно быть возвращено -1.

// Например:
// findNextSquare(9); --> 16
// findNextSquare(16); --> 25
// findNextSquare(64); --> 81
// ```

// ```jsx
// Напишите функцию так, чтобы она разбивала оболочку camelCase,
// используя пробел между словами.

// Например:
// "camelCasing"  -->  "camel Casing"

// "identifier"  -->  "identifier"

// "" -->  ""
// ```

// ```jsx
// Создайте функцию с именем divisors, которая принимает
// целое число n > 1 и возвращает массив со всеми делителями 
// целого числа (кроме 1 и самого числа), от наименьшего до наибольшего.
// Если число простое, верните строку '(integer) is prime'
// ```

// ```jsx
// Нарциссическое число - это число длины n, в котором
// сумма цифр в степени n равна исходному числу.

// Например:
// isNarcissistic(153) --> true;
// isNarcissistic(435) --> false;
// isNarcissistic(370) --> true;
// isNarcissistic(1032) --> false;
// ```

// ```jsx
// Если мы перечислим все натуральные числа ниже 10, 
// которые кратны 3 или 5, мы получим 3, 5, 6 и 9. Сумма этих кратных 23.
// Завершите решение так, чтобы оно возвращало 
// сумму всех кратных 3 или 5 числам ниже переданного числа.

// Например:
// solution(10) --> 23
// solution(12) --> 33
// solution(23) --> 119
// ```

// ```jsx
// Вам предоставляется массив (который будет иметь длину не менее 3, 
// но может быть очень большим),
// содержащий целые числа. Массив либо полностью состоит из нечетных целых чисел,
// либо полностью состоит из четных целых чисел,
// за исключением одного целого числа N.
// Напишите метод, который принимает массив в качестве аргумента и возвращает
// этот «выброс» N.

// Например:
// findOutlier([0, 1, 2]) --> 1
// findOutlier([1, 2, 3]) --> 2
// findOutlier([2,6,8,10,3]) --> 3
// findOutlier([1,1,0,1,1]) --> 0
// ```

// ```jsx
// Переместите первую букву каждого слова в его конец,
// затем добавьте «ау» в конец слова. Не трогайте знаки препинания.

// Например:
// pigIt('Pig latin is cool') --> 'igPay atinlay siay oolcay'
// pigIt('This is my string') --> 'hisTay siay ymay tringsay'
// ```

// ```jsx
// Напишите функцию, которая принимает строку круглых скобок и определяет,
// допустим ли порядок скобок.
// Функция должна возвращать истину, если строка действительна,
// и ложь, если она недействительна.

// Например:
// validParentheses(')(()))') --> false
// validParentheses('()') --> true
// validParentheses('()()') --> true
// validParentheses('()((()') --> false
// ```

// ```jsx
// Маркетинговая команда тратит слишком много времени на ввод хэштегов.
// Давайте поможем им с нашим собственным генератором хештегов!
// Он должен начинаться с хэштега (#).
// Все слова должны начинаться с заглавной буквы.
// Если окончательный результат длиннее 140 символов, он должен вернуть false.
// Если ввод или результат - пустая строка, он должен вернуть false.

// Например:
// " Hello there thanks for trying my Kata"  -->  "#HelloThereThanksForTryingMyKata"
// "    Hello     World   "   -->  "#HelloWorld"
// ""  -->  false
// ```

// ```jsx
// Дан массив целых чисел, найдите тот, который встречается нечетное количество раз.
// Всегда будет только одно целое число, которое встречается нечетное количество раз.

// Например:
// func([20,1,-1,2,-2,3,3,5,5,1,2,4,20,4,-1,-2,5]) --> 5
// func([1,1,2,-2,5,2,4,4,-1,-2,5]) --> -1
// func([20,1,1,2,2,3,3,5,5,4,20,4,5]) --> 5
// ```

// ```jsx
// Реализуйте функцию unique_in_order, которая принимает в качестве аргумента
// последовательность и возвращает список элементов
// без каких-либо элементов с одинаковым значением рядом
// друг с другом и с сохранением исходного порядка элементов.

// Например:
// uniqueInOrder('AAAABBBCCDAABBB') --> ['A', 'B', 'C', 'D', 'A', 'B']
// uniqueInOrder('ABBCcAD')         --> ['A', 'B', 'C', 'c', 'A', 'D']
// uniqueInOrder([1,2,2,3,3])       --> [1,2,3]
// ```

// ```jsx
// Для данного n возьмите сумму цифр n. 
// Если это значение имеет более одной цифры, 
// продолжайте уменьшать таким образом, пока
// не будет получено однозначное число. 
// Входными данными будет неотрицательное целое число.

// Например:
// digital_root(16)  -->  1 + 6 = 7
// digital_root(942)  --> 9 + 4 + 2 = 15  -->  1 + 5 = 6
// digital_root(132189) -->  1 + 3 + 2 + 1 + 8 + 9 = 24  -->  2 + 4 = 6
// digital_root(493193)  -->  4 + 9 + 3 + 1 + 9 + 3 = 29  -->  2 + 9 = 11  -->  1 + 1 = 2
// ```




let word = ['banana', 'grape', 'banana', 'grape', 'banana', 'orange', 'banana'];

const mySort = (arr) => {

    const temp = arr.reduce((acc, cur) => {
        acc[cur] = (acc[cur] ?? 0) + 1;
        return acc;
    }, {});
    console.log(temp);
    const key = Object.keys(temp);
    return key.sort((a, b) => temp[a] - temp[b]);
};
console.log(mySort(word));


